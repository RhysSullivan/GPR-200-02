// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> BUFFER A TAB (scene)

//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
#define NMOUSE
color4 calcColor(in sViewport vp, in sRay ray)
{    
      
    #ifdef MOUSE
    float pi = 3.14;
    vec3 dir = ray.direction.xyz; // base direction for the ray      
    vec2 mouse = texture(iChannel1, vec2(0.,0.)).xy;
    vec2 theta = (mouse * 2. * pi) - 1.; // theta represents the angle that we are rotating at, this maps x to be from -1 to 2pi-1
    mat2 mX = mat2(cos(theta.x), -sin(theta.x), sin(theta.x), cos(theta.x)); // rotation matrix for x    
    mat2 mY = mat2(cos(theta.y), -sin(theta.y), sin(theta.y), cos(theta.y)); // rotation matrix for y
	dir.zy *= -mY; // unflip rotation and apply y rotation
    dir.zx *= mX; // apply x rotation        
	return texture(iChannel0, dir); // color of surface    	
    #endif
    vec3 cubeLoc = ray.direction.xyz; // infinite direction on our ray out into 3d space	
	float rot = 80.; //* iTime / 100.; // basic rotation matrix
    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
    cubeLoc.xz *= m;
    return texture(iChannel0, cubeLoc);    
}


// Code extended by Rhys Sullivan
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    fragColor += calcColor(vp, ray);
}