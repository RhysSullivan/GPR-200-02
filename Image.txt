#define NUM_SPHERES 3
struct FSphere
{
	vec4 center;   
    float radius;      
};

struct FHitRecord
{
    vec4 p;
	vec4 normal;
    float t;
    bool frontFace;
};

/*
FUNCTION PROTOTYPES
*/
// objects
bool hit(FSphere sphere, vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord);
bool hitWorld(vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord, FSphere spheres[NUM_SPHERES]);

// utility
float vec4LengthSquared(vec4 rayDirection);
vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t);
vec4 unitVector(in vec4 ray);
void set_face_normal(out FHitRecord rec, vec4 rayDirection, vec4 rayOrigin, vec4 outward_normal);
float rand(out float seed);
vec4 randVec(out float seed);
vec4 randomInUnitSphere(float seed);

// image
void calcViewport(out float seed, out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution);
void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength);
vec4 calcColor(in float seed, in vec4 rayDirection, in vec4 rayOrigin, FSphere spheres[NUM_SPHERES]);


/*
MAIN IMAGE
*/
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;  
     
    FSphere spheres[NUM_SPHERES];
    spheres[0].center = vec4(sin(iTime),0.,-1.5+-abs(cos(iTime)),1.);
    spheres[0].radius = .5;
    spheres[1].center = vec4(sin(iTime),1.,-1.5+-abs(sin(iTime)),1.);
    spheres[1].radius = .5;            
    spheres[2].center = vec4(0.,-100.5,-1.,1.);
    spheres[2].radius = 100.;
    
    
    
    int samplesPerPixel = 100;    
    int maxDepth = 50;
    vec4 accCol;
    float seed = iDate.x;
    
    for(int s = 0; s < samplesPerPixel; ++s)
    {                
    	calcViewport(seed, viewport, ndc, uv, aspect, resolutionInv, viewportHeight, fragCoord, iResolution.xy);
	    calcRay(rayDirection, rayOrigin, viewport, focalLength);
	    accCol += calcColor(seed, rayDirection, rayOrigin, spheres);	               
    }    
    float scale = 1. / float(samplesPerPixel);
    accCol = sqrt(scale * accCol);
	fragColor = accCol;
}


// objects
bool hit(FSphere sphere, vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord rec)
{ 
    vec4 oc = rayOrigin - sphere.center;
    float a = vec4LengthSquared(rayDirection);
    float half_b = dot(oc, rayDirection);
    float c = vec4LengthSquared(oc) - (sphere.radius * sphere.radius);
    float discriminant = half_b*half_b - a*c;
    
	if (discriminant > 0.)
    {
        float root = sqrt(discriminant);
        
        float temp = (-half_b - root) / a; 
        if(temp < t_max && temp > t_min)
        {           
         	rec.t = temp;
            rec.p = at(rayOrigin, rayDirection, rec.t);
            vec4 outward_normal = (rec.p - sphere.center) / sphere.radius;
            set_face_normal(rec, rayDirection, rayOrigin, outward_normal);                                                
            return true;
        }
        
        temp = (-half_b + root) / a;
        if(temp < t_max && temp > t_min)
        {
         	rec.t = temp;
            rec.p = at(rayOrigin, rayDirection, rec.t);
            vec4 outward_normal = (rec.p - sphere.center) / sphere.radius;
            set_face_normal(rec, rayDirection, rayOrigin, outward_normal);
            return true;
        }        
    }            
    return false;        
}

bool hitWorld(FSphere spheres[NUM_SPHERES], vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord)
{
    FHitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;
           
    for(int i = 0; i < NUM_SPHERES; ++i)
    {
        FSphere sphere = spheres[i];				    
    	if(hit(sphere, rayDirection, rayOrigin, t_min, closest_so_far, temp_rec))
    	{
    	    hit_anything = true;
    	    closest_so_far = temp_rec.t;
			hitRecord = temp_rec;
    	}    
    }        
    return hit_anything;
}

// utility
float vec4LengthSquared(vec4 rayDirection){
    return dot(rayDirection, rayDirection);
}

vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t){
    return rayOrigin + t*rayDirection;
}

vec4 unitVector(in vec4 ray){
 return ray / length(ray);
}

void set_face_normal(out FHitRecord rec, vec4 rayDirection, vec4 rayOrigin, vec4 outward_normal){
    rec.frontFace = dot(rayDirection, outward_normal) < 0.;
    rec.normal = rec.frontFace ? outward_normal : -outward_normal;
}

float rand(out float seed){
    float random = (fract(sin(seed) * 100000.0f)-0.5) * 2.0;
    seed++;
    return random;
}

vec4 randVec(out float seed){
      while(true){
        vec4 p = vec4(rand(seed), rand(seed), rand(seed), 0.);
        if (dot(p, p) >= 1.0f) continue;
        return p;
    }   
}

vec4 randomInHemisphere(vec4 normal, in float seed){
 vec4 in_unit_sphere = randVec(seed);
    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return in_unit_sphere;
    else
        return -in_unit_sphere;   
}
// image
vec4 calcColor(in float seed, in vec4 rayDirection, in vec4 rayOrigin, FSphere spheres[NUM_SPHERES]){
    vec4 sumCol = vec4(1.);
    vec4 rD = rayDirection;
    vec4 rO = rayOrigin;
    int i;
	for(i = 0; i < 50; i++)
    {        
		FHitRecord rec;
    	if( hitWorld(spheres, rD, rO, 0.001, 100000000000000., rec) )
    	{
            vec4 target = rec.p + randomInHemisphere(rec.normal, seed);
            rO = rec.p;
            rD = target - rec.p;
    	    sumCol *= .5;                        
    	}
        else
        	break;
          
    }        
    float t = 0.5 *(unitVector(rD).y + 1.0);
    sumCol *= (1.0-t)*vec4(.0,.0,1.0,1.0) + t*vec4(0.9,0.2,.0,1.0); 
    return sumCol;
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength){
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}

void calcViewport(out float seed, out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution){
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;
    
    // subpixel sampling   
    uv.x += rand(seed) * resolutionInv.x;
	uv.y += rand(seed) * resolutionInv.y;
    
    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}