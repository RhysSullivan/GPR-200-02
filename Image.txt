// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
// Code extended by Rhys Sullivan
// Referenced https://www.raywenderlich.com/146-unreal-engine-4-cel-shading-tutorial for cel shading
struct FPointLight
{
 	vec4 center;
    vec3 color;
    float intensity;
};
  
    
void initPointLight(out FPointLight pLight, vec4 center, vec3 color, float intensity)
{
    pLight.center = center;
    pLight.color = color;
    pLight.intensity = intensity;    
}
    
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

void calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,out float aspect, out vec2 resolutionInv, in float viewportHeight, in float focalLength, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f
    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec3 eyePosition, in vec3 viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = asOffset(viewport - eyePosition);
}

struct FSphere
{
 	vec4 center;
    float radius;
};

void initSphere(out FSphere sphere, in vec3 center, in float radius)
{
 	sphere.center = asPoint(center);
    sphere.radius = radius;
}

float lenSq(vec2 x)
{
 return dot(x,x);   
}

float lambertianReflectance(vec3 norm, vec3 pos, vec3 L, FPointLight pLight)
{
 float difCoeff = dot(norm, vec3(L)); 	
 float d = length(vec3(pLight.center) - pos);
 float iL = pLight.intensity;
 float d2 = d * d;
 float iL2 = iL * iL;
 float intensity = 1./(1. + d/iL + d2 / iL);
 return intensity * difCoeff; 		 		   
}

float phongReflectance(vec3 pos, vec3 norm, FPointLight pLight, vec3 rayOrigin)
{
   // Phong Reflectance
   vec3 L = normalize(vec3(pLight.center) - pos); // Light Vector        
   vec3 V = normalize(rayOrigin - pos); // View Vector
   vec3 R = reflect(-L, norm);
   float kS = dot(V,R);   
   kS = max(kS, 0.);
    
   float iS = pow(kS, 16.);
   return iS;
}

float blinnPhongReflectance(vec3 pos, vec3 norm, FPointLight pLight, vec3 rayOrigin)
{
   vec3 L = normalize(vec3(pLight.center) - pos); 
   vec3 V = normalize(vec3(rayOrigin) - pos);   
   vec3 H = normalize(L+V);
   float kS = dot(norm,H);
   kS = max(kS, 0.);
   float iS = pow(kS, 256.0); 
   return iS;
}

float celShade(float iD, float bands)
{
 for(float i = 0.; i < 1.; i += bands)
 {
  if(iD < i)
  {
   iD = i;
   return iD;
  }
 }   
  return 1.;
}

vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{
	FSphere sphere;
    initSphere(sphere, vec3(0.,0., -4.), .4);
    vec3 dp;
    dp.xy = rayDirection.xy - sphere.center.xy;
    float sqLen = lenSq(dp.xy);
    float rSq = sphere.radius * sphere.radius;
    if(sqLen <= rSq)
    {
		dp.z = rSq - (sqLen);
		vec3 pos = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));
        vec3 norm = (pos - sphere.center.xyz) / sphere.radius;                
        
        #define NUM_LIGHTS 3
        FPointLight[NUM_LIGHTS] pLights;
        initPointLight(pLights[0],
                       vec4(1.,2.,cos(iTime*3.)*-4.,1.), 
                       vec3(.8,.6,0.),
                       20.);
        initPointLight(pLights[1],
                       vec4(sin(iTime*3.)*-40.,-2.,20.,1.), 
                       vec3(.0,.0,.8), 
                       10.);
        initPointLight(pLights[2],
                       vec4(sin(iTime*3.)*10.,-10.,0.,1.),
                       vec3(.8,.0,.8),
                       20.);        
        vec3 sumCol;
        float iA = .1;
		vec3 cA = vec3(1.);
        for(int i = NUM_LIGHTS-1; i >= 0; --i)
        {
            // ID Start
            float d = length(vec3(pLights[i].center) - pos); // distance between light center and surface point
            float inv = 1./d; // precompute the inverse for speed            
	 	    vec3 L = (vec3(pLights[i].center) - pos) * inv; // Light Vector
            float kD = dot(norm, L); //diffuse coefficient
            kD = max(kD, 0.);
 			float iL = pLights[i].intensity; // original light intensity
            float iLinv = 1./iL; // precompute inverse of light intensity
            float intensity = 1./(1. + d * iLinv + (d * iLinv * d * iLinv)); 
 			float iD = intensity * kD; // diffuse intensity
            //iD = celShade(iD, .2);       
            // ID END
                        
            
            // IS Start
            #define BFP
            #ifdef BF            
   			vec3 V = normalize(vec3(rayOrigin) - pos); // View Vector   			
            vec3 R = reflect(-L, norm); // Reflect is: - 2.0 * dot(N, I) * N.
   			float kS = dot(V,R); // Specular Coefficient
   			kS = max(kS, 0.); //    
   			float iS = kS; // final specular intensity
            iS *= iS; // 2
            iS *= iS; // 4
            iS *= iS; // 8
            iS *= iS; // 16
            iS *= iS; // 32
            iS *= iS; // 64		
            #endif
            #ifdef BFP
            float iS = blinnPhongReflectance(pos, norm, pLights[i], vec3(rayOrigin));
            #endif
            // IS End  
                        
			vec3 cD  = vec3(norm * .5 + .5); // Diffuse reflection of surface
            vec3 cS  = vec3(1.); // specular reflection color
            sumCol  += ((iD * cD) + (iS * cS)) * pLights[i].color;
        } 
        sumCol += (iA * cA);   
        return vec4(sumCol,1.);
    }
    vec4 top = vec4(.2,.4,.7,1.);
    vec4 bottom = vec4(.0,.2,.2,1.);
	return mix(bottom, top, rayDirection.y+.5);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info
    vec3 viewport;
    vec2 ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    fragColor = vec4(0.0);
    
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
    	             viewportHeight, focalLength,
    	             fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);
    
    fragColor += calcColor(rayDirection, rayOrigin);
}