struct FSphere
{
	vec4 center;   
    float radius;      
};

struct FHitRecord
{
    vec4 p;
	vec4 normal;
    float t;
    bool frontFace;
};

// function prototypes
bool hit(FSphere sphere, vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord);
bool hitWorld(vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord);

float vec4LengthSquared(vec4 rayDirection);
vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t);
vec4 unitVector(in vec4 ray);
void set_face_normal(out FHitRecord rec, vec4 rayDirection, vec4 rayOrigin, vec4 outward_normal);
float rand(float seed) { return fract(sin(seed)*3000.*(iTime)); } // TODO: Change 3k
float rand(vec2 seed){ return fract(sin(dot(seed.xy, vec2(12.9898,78.233)))* 43758.5453123);}

void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution);
void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength);
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin);


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
                 viewportHeight, fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin,
            viewport, focalLength);

    int samplesPerPixel = 100;
    
    vec4 accCol;
    
    for(int s = 0; s < samplesPerPixel; ++s)
    {                
        accCol += calcColor(rayDirection, rayOrigin);	               
    }    
    accCol /= float(samplesPerPixel);
	fragColor = accCol;
}

bool hit(FSphere sphere, vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord rec)
{ 
    vec4 oc = rayOrigin - sphere.center;
    float a = vec4LengthSquared(rayDirection);
    float half_b = dot(oc, rayDirection);
    float c = vec4LengthSquared(oc) - (sphere.radius * sphere.radius);
    float discriminant = half_b*half_b - a*c;
    
	if (discriminant > 0.)
    {
        float root = sqrt(discriminant);
        
        float temp = (-half_b - root) / a; 
        if(temp < t_max && temp > 0.)
        {           
         	rec.t = temp;
            rec.p = at(rayOrigin, rayDirection, rec.t);
            vec4 outward_normal = (rec.p - sphere.center) / sphere.radius;
            set_face_normal(rec, rayDirection, rayOrigin, outward_normal);                                                
            return true;
        }
        
        temp = (-half_b + root) / a;
        if(temp < t_max && temp > t_min)
        {
         	rec.t = temp;
            rec.p = at(rayOrigin, rayDirection, rec.t);
            vec4 outward_normal = (rec.p - sphere.center) / sphere.radius;
            set_face_normal(rec, rayDirection, rayOrigin, outward_normal);
            return true;
        }        
    }            
    return false;        
}

bool hitWorld(vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord)
{
    FHitRecord temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;
    
    
    FSphere spheres[2];
    spheres[0].center = vec4(0.,0.,-1.,1.);
    spheres[0].radius = .5;
    spheres[1].center = vec4(0.,-100.5,-1.,1.);
    spheres[1].radius = 100.;
    for(int i = 0; i < 2; ++i)
    {
        FSphere sphere = spheres[i];				    
    	if(hit(sphere, rayDirection, rayOrigin, t_min, closest_so_far, temp_rec))
    	{
    	    hit_anything = true;
    	    closest_so_far = temp_rec.t;
			hitRecord = temp_rec;
    	}    
    }        
    return hit_anything;
}

void set_face_normal(out FHitRecord rec, vec4 rayDirection, vec4 rayOrigin, vec4 outward_normal)
{
    rec.frontFace = dot(rayDirection, outward_normal) < 0.;
    rec.normal = rec.frontFace ? outward_normal : -outward_normal;
}



float vec4LengthSquared(vec4 rayDirection)
{
    return dot(rayDirection, rayDirection);
}

vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t){ return rayOrigin + t*rayDirection;}

vec4 unitVector(in vec4 ray)
{
 return ray / vec4LengthSquared(ray);   
}

vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{
    FHitRecord rec;
    if( hitWorld(rayDirection, rayOrigin, 0., 1000000000., rec) )
    {
        return .5 * (rec.normal + vec4(1.));
    }
    float t = 0.5 *(unitVector(rayDirection).y + 1.0);
    return (1.0-t)*vec4(1.0,1.0,1.0,1.0) + t*vec4(0.5,0.7,1.0,1.0);
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}

void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;
    
    // subpixel sampling
    uv.x += rand(uv.x) * resolutionInv.x;
	uv.y += rand(uv.y) * resolutionInv.y;
    
    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}