// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
// Code extended by Rhys Sullivan
struct FPointLight
{
 	vec4 center;
    vec3 color;
    float intensity;
};
    
void initPointLight(out FPointLight pLight, vec4 center, vec3 color, float intensity)
{
    pLight.center = center;
    pLight.color = color;
    pLight.intensity = intensity;    
}
    
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

void calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,out float aspect, out vec2 resolutionInv, in float viewportHeight, in float focalLength, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f
    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec3 eyePosition, in vec3 viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = asOffset(viewport - eyePosition);
}

struct FSphere
{
 	vec4 center;
    float radius;
};

void initSphere(out FSphere sphere, in vec3 center, in float radius)
{
 	sphere.center = asPoint(center);
    sphere.radius = radius;
}

float lenSq(vec2 x)
{
 return dot(x,x);   
}

float diffuseIntensity(vec3 norm, vec3 pos, vec3 L, FPointLight pLight)
{
 float difCoeff = dot(norm, vec3(L)); 	
 float d = length(vec3(pLight.center) - pos);
 float iL = pLight.intensity;
 float d2 = d * d;
 float iL2 = iL * iL;
 float intensity = 1./(1. + d/iL + d2 / iL);
 return intensity * difCoeff; 		 		   
}

float lambertianReflectance(vec3 pos, vec3 norm, FPointLight pLight)
{ 	
 	vec3 L = normalize(vec3(pLight.center) - pos);        
 	float iD = diffuseIntensity(norm, pos, L, pLight); 	 
    return iD;
    //vec3 difColor = vec3(norm*.5+.5);
 	//vec3 lightCol = vec3(pLight.color);
 	//return vec4(iD * difColor * lightCol, 0.);   
}

float phongReflectance(vec3 pos, vec3 norm, FPointLight pLight, vec3 rayOrigin)
{
   // Phong Reflectance
   vec3 L = normalize(vec3(pLight.center) - pos); // Light Vector        
   vec3 V = normalize(rayOrigin - pos); // View Vector
   vec3 R = reflect(-L, norm);
   float kS = dot(V,R);   
   kS = max(kS, 0.);
    
   float iS = pow(kS, 16.);
   return iS;
}

float blinnPhongReflectance(vec3 pos, vec3 norm, FPointLight pLight, vec3 rayOrigin)
{
   vec3 V = normalize(vec3(rayOrigin) - pos);
   vec3 L = normalize(vec3(pLight.center) - pos); 
   vec3 H = normalize(L+V);
   float kS = dot(norm,H);
   float iS = pow(kS, 128.0); 
   return iS;
}

vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{
	FSphere sphere;
    initSphere(sphere, vec3(0.,0., -4.), .4);
    vec3 dp;
    dp.xy = rayDirection.xy - sphere.center.xy;
    float sqLen = lenSq(dp.xy);
    float rSq = sphere.radius * sphere.radius;
    if(sqLen <= rSq)
    {
		dp.z = rSq - (sqLen);
		vec3 pos = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));
        vec3 norm = (pos - sphere.center.xyz) / sphere.radius;                
        
        #define NUM_LIGHTS 3
        FPointLight[NUM_LIGHTS] pLights;
        initPointLight(pLights[0],
                       vec4(1.,2.,cos(iTime*3.)*-4.,1.), 
                       vec3(.8,.6,0.),
                       20.);
        initPointLight(pLights[1],
                       vec4(30.,sin(iTime*3.)*-2.,20.,1.), 
                       vec3(.0,.0,.8), 
                       20.);
        initPointLight(pLights[2],
                       vec4(sin(iTime*3.)*10.,-10.,0.,1.),
                       vec3(.8,.0,.8),
                       20.);        
        vec3 sumCol;
        float iA = .3;
		vec3 cA = vec3(1.);
        for(int i = 0; i < NUM_LIGHTS; ++i)
        {
            // ID Start
            float d = length(vec3(pLights[i].center) - pos);
            float inv = 1./d;
            vec3 L = (vec3(pLights[i].center) - pos) * inv;        
            float difCoeff = dot(norm, L); 	 			
 			float iL = pLights[i].intensity;
            float iLinv = 1./iL;
            float intensity = 1./(1. + d * iLinv + (d * iLinv * d * iLinv));
 			float iD =  intensity * difCoeff; 	             			
            // ID END
            vec3 cD  = vec3(norm * .5 + .5);
            
            // IS Start
   			vec3 V = normalize(vec3(rayOrigin) - pos); // View Vector
   			vec3 R = reflect(-L, norm);
   			float kS = dot(V,R);   
   			kS = max(kS, 0.);    
   			float iS = pow(kS, 16.);
			// IS End
            
            vec3 cS  = vec3(1.);            
            sumCol  += ((iD * cD) + (iS * cS)) * pLights[i].color;
        } 
        sumCol += (iA * cA);
        return vec4(sumCol,1.);
    }
    vec4 top = vec4(.2,.4,.7,1.);
    vec4 bottom = vec4(.0,.2,.2,1.);
	return mix(bottom, top, rayDirection.y+.5);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info
    vec3 viewport;
    vec2 ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    fragColor = vec4(0.0);
    
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
    	             viewportHeight, focalLength,
    	             fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);
    
    fragColor += calcColor(rayDirection, rayOrigin);
}