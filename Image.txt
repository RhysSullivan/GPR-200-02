float vec4Length(vec4 rayDirection)
{
    return dot(rayDirection, rayDirection);
}

vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t){ return rayOrigin + t*rayDirection;}

vec4 unitVector(in vec4 ray)
{
 return ray / dot(ray,ray);   
}

float hit_sphere(vec4 center, float radius, vec4 rayDirection, vec4 rayOrigin) 
{
    vec4 oc = rayOrigin - center;
    float a = vec4Length(rayDirection);
    float b = 2. * dot(oc, rayDirection);
    float c = vec4Length(oc) - radius * radius;
    float discriminant = b*b - 4.*a*c;
	if (discriminant < 0.)
    {
        return -1.0;
    }
    else
    {
     return (-b - sqrt(discriminant) ) / (2.0 * a);   
    }
    return 0.;
}

vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{
    float t = hit_sphere(vec4(0.,0.,-1.,1.), 0.5, rayDirection, rayOrigin);
    if(t > 0.)
    {
     	vec4 N = unitVector(at(rayOrigin, rayDirection, t) - vec4(0.,0.,-1.,0.));
        return 0.5*vec4(N.x + 1., N.y + 1., N.z + 1., 0.0);
    }
    t = 0.5 *(unitVector(rayDirection).y + 1.0);
    return (1.0-t)*vec4(1.0,1.0,1.0,1.0) + t*vec4(0.5,0.7,1.0,1.0);
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}

void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
                 viewportHeight, fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin,
            viewport, focalLength);

    // color
    fragColor = calcColor(rayDirection, rayOrigin);

    // TEST COLOR:
    //  -> what do the other things calculated above look like?
    //fragColor = vec4(viewport, 0.0, 0.0);
    //fragColor = vec4(ndc, 0.0, 0.0);
    //fragColor = vec4(uv, 0.0, 0.0);
}