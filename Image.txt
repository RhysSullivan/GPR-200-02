// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
// Code extended by Rhys Sullivan
struct FPointLight
{
 	vec4 center;
    vec4 color;
    float intensity;
};
    
void initPointLight(out FPointLight pLight, vec4 center, vec4 color, float intensity)
{
    pLight.center = center;
    pLight.color = color;
    pLight.intensity = intensity;    
}
    
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

void calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,out float aspect, out vec2 resolutionInv, in float viewportHeight, in float focalLength, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f
    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec3 eyePosition, in vec3 viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = asOffset(viewport - eyePosition);
}

struct FSphere
{
 	vec4 center;
    float radius;
};

void initSphere(out FSphere sphere, in vec3 center, in float radius)
{
 	sphere.center = asPoint(center);
    sphere.radius = radius;
}

float lenSq(vec2 x)
{
 return dot(x,x);   
}

float diffuseIntensity(vec3 norm, vec3 pos, vec3 L, FPointLight pLight)
{
 float difCoeff = dot(norm, vec3(L)); 	
 float d = length(vec3(pLight.center) - pos);
 float iL = pLight.intensity;
 float d2 = d * d;
 float iL2 = iL * iL;
 float intensity = 1./(1. + d/iL + d2 / iL);
 return intensity * difCoeff; 		 		   
}

vec4 lambertianReflectance(vec3 pos, vec3 norm, FPointLight pLight)
{
 	// Diffuse Coefficient
 	vec3 L = normalize(vec3(pLight.center) - pos);        
 	float iD = diffuseIntensity(norm, pos, L, pLight); 	 
    vec3 difColor = vec3(1.);
 	vec3 lightCol = vec3(pLight.color);
 	return vec4(iD * difColor * lightCol, 0.);   
}

vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{
    // DUMMY RESULT: OUTPUT RAY DIRECTION AS-IS
    //  -> what does the ray look like as color?
    //return rayDirection;
	
	FSphere sphere;
    initSphere(sphere, vec3(0.,0., -4.), .4);
    vec3 dp;
    dp.xy = rayDirection.xy - sphere.center.xy;
    float sqLen = lenSq(dp.xy);
    float rSq = sphere.radius * sphere.radius;
    if(sqLen <= rSq)
    {
		dp.z = rSq - (sqLen);
		vec3 pos = sphere.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z));
        vec3 norm = (pos - sphere.center.xyz) / sphere.radius;
        
        // Lambertian Reflectance
        FPointLight pLight;
        //initPointLight(pLight, vec4(2.,2.,-1.,1.), vec4(.8,.2,0.,0.), 15.);                
        initPointLight(pLight, vec4(2.,2.,-1.,1.), vec4(1.), 10.);                
        //return lambertianReflectance(pos, norm, pLight);
        
        
        // Phong Reflectance
        vec3 L = normalize(vec3(pLight.center) - pos); // Light Vector        
        vec3 V = normalize(vec3(rayOrigin) - pos); // View Vector
        vec3 R = reflect(-L, norm);
        float kS = dot(V,R);
        kS = max(0., kS);               
        float iS = pow(kS, 8.);
                
        float iA = .1; // global ambient intensity
        vec3 cA = vec3(0.,0.,.2); // global ambient coor                
 		float iD = diffuseIntensity(norm, pos, L, pLight); // Light Diffuse Intensity        
        vec3 cD = vec3(norm); // Diffuse Reflection of Surface
        vec3 cS = vec3(1.); // Specular Reflection Color
        vec3 cL = vec3(pLight.color); // Light Color        
        
        return vec4( (iA*cA+(iD*cD+iS*cS)*cL), 1.);
        
    }
	return vec4(.2);
}

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // viewing plane (viewport) info
    vec3 viewport;
    vec2 ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    fragColor = vec4(0.0);
    
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
    	             viewportHeight, focalLength,
    	             fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);
    
    fragColor += calcColor(rayDirection, rayOrigin);
}