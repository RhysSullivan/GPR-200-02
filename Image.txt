//Code by Rhys Sullivan,
// referenced: https://thebookofshaders.com/10/
#define NUM_SPHERES 3
#define CELL_SHADE false
#define MAX_DEPTH 50
struct FSphere
{
	vec4 center;   
    float radius;      
};

struct FHitRecord
{
    vec4 p;
	vec4 normal;
    float t;
    bool frontFace;
};

/*
FUNCTION PROTOTYPES
*/
// objects
bool hit(FSphere sphere, vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord);
bool hitWorld(vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord, FSphere spheres[NUM_SPHERES]);

// utility
float vec4LengthSquared(vec4 rayDirection);
vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t);
vec4 unitVector(in vec4 ray);
void set_face_normal(out FHitRecord rec, vec4 rayDirection, vec4 rayOrigin, vec4 outward_normal);
float rand(out float seed);
vec4 randVec(out float seed);
vec4 randomInUnitSphere(float seed);

// image
void calcViewport(out float seed, out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution);
void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength);
vec4 calcColor(in float seed, in vec4 rayDirection, in vec4 rayOrigin, FSphere spheres[NUM_SPHERES]);


/*
MAIN IMAGE
*/
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;
    
    // time from 0 to 5, hard reset back to 5
	float t = mod(iTime, 5.);     
    //-2.5 to 2.5 is our range of x values in the camera    
    float x = -2.5 + (t) * 2.5;
    float y = abs( (sin(x * 3.) / (mod(x, 2.) + 1.) )) / 55.; // ugly math for a cute bounce
    y *= 30.; // add scale to the y value
    
    FSphere spheres[NUM_SPHERES];
    spheres[0].center = vec4(x,y,-1.,1.);
    spheres[0].radius = .5;
    spheres[1].center = vec4(x-2.5,y,-1.7,1.);
    spheres[1].radius = .5;            
    spheres[2].center = vec4(0.,-100.5,-1.,1.);
    spheres[2].radius = 100.;    
    
   	// Setup of variables for the image 
    int samplesPerPixel = 50;
    float seed = iDate.x; //seed for the random value
    vec4 rayDirection, rayOrigin, accCol; //accCol is the accumulated colors
    for(int s = samplesPerPixel; s >= 0; --s)
    {                
    	calcViewport(seed, viewport, ndc, uv, aspect, resolutionInv, viewportHeight, fragCoord, iResolution.xy);
	    calcRay(rayDirection, rayOrigin, viewport, focalLength);
	    accCol += calcColor(seed, rayDirection, rayOrigin, spheres); //add our subpixel color to the accumulated colors
    }    
    float scale = 1. / float(samplesPerPixel);
    accCol = sqrt(scale * accCol);
	fragColor = accCol;
}

// objects
bool hit(FSphere sphere, vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord rec)
{ 
    vec4 oc = rayOrigin - sphere.center; // vector from the ray origin to the center
    float a = vec4LengthSquared(rayDirection); 
    float half_b = dot(oc, rayDirection);
    float c = vec4LengthSquared(oc) - (sphere.radius * sphere.radius);
    float discriminant = half_b*half_b - a*c; // this block of code is representing the sphere intersection equation
    
	if (discriminant > 0.)
    {
        float root = sqrt(discriminant);
		
		// Rays hitting outside of the sphere        
        float temp = (-half_b - root) / a; 
        if(temp < t_max && temp > t_min)
        {           
         	rec.t = temp;
            rec.p = at(rayOrigin, rayDirection, rec.t);
            vec4 outward_normal = (rec.p - sphere.center) / sphere.radius;
            set_face_normal(rec, rayDirection, rayOrigin, outward_normal);                                                
            return true;
        }

        // Handle being inside of the sphere 
        temp = (-half_b + root) / a;
        if(temp < t_max && temp > t_min)
        {
         	rec.t = temp;
            rec.p = at(rayOrigin, rayDirection, rec.t);
            vec4 outward_normal = (rec.p - sphere.center) / sphere.radius;
            set_face_normal(rec, rayDirection, rayOrigin, outward_normal);
            return true;
        }        
    }            
    return false;        
}

bool hitWorld(FSphere spheres[NUM_SPHERES], vec4 rayDirection, vec4 rayOrigin, float t_min, float t_max, out FHitRecord hitRecord)
{
    FHitRecord temp_rec; // temporary record
    bool hit_anything = false;
    float closest_so_far = t_max; // closest sphere we have hit
           
    for(int i = 0; i < NUM_SPHERES; ++i) // loop through all spheres in array, a cleaner implementation may allow for the ability to pass in abitrary objects but i was unsure how to do that w/out inheritance
    {
        FSphere sphere = spheres[i];				    
    	if(hit(sphere, rayDirection, rayOrigin, t_min, closest_so_far, temp_rec))
    	{
    	    hit_anything = true;
    	    closest_so_far = temp_rec.t;
			hitRecord = temp_rec;
    	}    
    }        
    return hit_anything;
}

// utility
float vec4LengthSquared(vec4 rayDirection){
    return dot(rayDirection, rayDirection); // wrapper function for flexability
}

vec4 at(in vec4 rayOrigin, in vec4 rayDirection, in float t){
    return rayOrigin + t*rayDirection; // walk up the ray direction to the time
}

vec4 unitVector(in vec4 ray){
 return ray / sqrt(vec4LengthSquared(ray)); // ew sqrt, has to be done for the normalized vector length
}

void set_face_normal(out FHitRecord rec, vec4 rayDirection, vec4 rayOrigin, vec4 outward_normal){
    rec.frontFace = dot(rayDirection, outward_normal) < 0.;
    rec.normal = rec.frontFace ? outward_normal : -outward_normal;
}

float rand(out float seed){
    float random = (fract(sin(seed) * 100000.0f)-0.5) * 2.0; // referenced: https://thebookofshaders.com/10/
    seed++;
    return random;
}

vec4 randVec(out float seed){ 
    while(true){
        vec4 p = vec4(rand(seed), rand(seed), rand(seed), 0.);
        if (dot(p, p) >= 1.0f) continue;
        return p;
    }   
}

vec4 randomInHemisphere(vec4 normal, in float seed){
vec4 in_unit_sphere = randVec(seed); // allows for a uniform scatter depending on the hit point
    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return in_unit_sphere;
    else
        return -in_unit_sphere;   
}
// image
vec4 calcColor(in float seed, in vec4 rayDirection, in vec4 rayOrigin, FSphere spheres[NUM_SPHERES]){
    vec4 sumCol = vec4(1.); // variable to keep track of the loop results
    vec4 rD = rayDirection; // setup rD and rO to change in the loop
    vec4 rO = rayOrigin; // ray origin variable
    int i; // track outside of the loop to add in black where i > 48 etc
	for(i = MAX_DEPTH; i >= 0; --i) // recursion is not supported, using this instead, starting at 50 for perf.
    {        
		FHitRecord rec;
    	if( hitWorld(spheres, rD, rO, 0.001, 100000000000000., rec) )
    	{
            vec4 target = rec.p + randomInHemisphere(rec.normal, seed); // our target point is our ray origin + some random bounce direction
            rO = rec.p; // update rO and rD to reflect the new random bounce
            rD = target - rec.p;
    	    sumCol *= .5; // lower the amount of lighting we get from the world per bounce                        
    	}
        else
        	break; // no hit means no bounce so we're done with the loop.
    }        
    float t = 0.5 *(unitVector(rD).y + 1.0); // get our t value from our position of the ray,
    sumCol *= mix(vec4(.0,.0,1.0,1.0),vec4(0.9,0.2,.0,1.0), t);  
    return sumCol;
}

void calcRay(out vec4 rayDirection, out vec4 rayOrigin, in vec2 viewport, in float focalLength){
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}

void calcViewport(out float seed, out vec2 viewport, out vec2 ndc, out vec2 uv, out float aspect, out vec2 resolutionInv,in float viewportHeight, in vec2 fragCoord, in vec2 resolution){
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;
    
    // subpixel sampling   
    uv.x += rand(seed) * resolutionInv.x;
	uv.y += rand(seed) * resolutionInv.y;
    
    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}